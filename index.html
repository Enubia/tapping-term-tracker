<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tapping Term Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .char {
            display: inline-block;
            font-family: monospace;
            transition: all 0.1s;
            margin-right: 0.05em;
        }

        .char:has(+ .char-space),
        .char-space {
            margin-right: 0.4em;
        }

        .char-current {
            position: relative;
        }

        .char-current::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 2px;
            background-color: #4f46e5;
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .char-correct {
            color: #10b981;
        }

        .char-incorrect {
            color: #ef4444;
            text-decoration: underline;
        }

        .char-upcoming {
            color: #6b7280;
        }

        /* Light mode */
        .stats-card {
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s, color 0.3s;
        }

        /* Dark mode */
        .bg-gray-900 .stats-card {
            background: #1f2937;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #typing-area {
            outline: 2px solid transparent;
            transition: outline 0.2s, background-color 0.3s, color 0.3s;
            letter-spacing: 0.05em;
            word-spacing: 0.5em;
            background-color: white;
        }

        .bg-gray-900 #typing-area {
            background-color: #1f2937;
        }

        #typing-area:focus {
            outline: 2px solid #4f46e5;
        }

        /* Number input styling */
        input[type="number"] {
            max-width: 60px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 2px 6px;
            text-align: center;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        .bg-gray-900 input[type="number"] {
            background-color: #374151;
            border-color: #4b5563;
            color: white;
        }

        input[type="number"]:focus {
            outline: 2px solid #4f46e5;
            border-color: transparent;
        }

        /* Hide spin buttons */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
        }

        input[disabled] {
            background-color: #f3f4f6;
            cursor: not-allowed;
        }

        .bg-gray-900 input[disabled] {
            background-color: #374151;
            opacity: 0.6;
        }

        /* Dark mode adaptation for container */
        .bg-gray-900 .bg-white {
            background-color: #1f2937;
        }
    </style>
</head>

<body class="bg-gray-100 p-6">
    <div class="container mx-auto max-w-3xl">
        <h1 class="text-3xl font-bold mb-2 text-center text-indigo-800 dark-mode-title">Tapping Term Tracker</h1>

        <!-- Description section -->
        <div class="text-center mb-6 max-w-2xl mx-auto">
            <p class="text-gray-600 dark:text-gray-300">
                Track and measure your individual key press durations to optimize your mechanical keyboard's QMK/ZMK firmware
                settings.
            </p>
            <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
                This tool helps determine your ideal tapping term values by measuring how long you typically hold each key. Keys
                with longer press times may benefit from adjusted tapping term configurations.
            </p>
        
            <!-- Disclaimer -->
            <div class="mt-4 text-xs bg-blue-50 dark:bg-blue-900 p-3 rounded-md text-blue-800 dark:text-blue-200 inline-block">
                <p><strong>Note:</strong> Results are relative measurements only. Physical key switch characteristics (spring
                    weight, actuation point)
                    and system latency aren't accounted for in these measurements.</p>
            </div>
        </div>

        <div class="bg-white rounded-lg p-6 shadow-md mb-6 transition-colors duration-300">
            <div id="typing-area" class="text-lg leading-relaxed mb-4 font-mono p-4 focus:outline-none rounded"
                tabindex="0">
                <!-- Text will be populated here -->
            </div>

            <div class="text-sm text-gray-500 flex justify-between items-center">
                <span>Click on the text area and start typing</span>
                <div class="flex items-center">
                    <label for="word-count-input" class="mr-2">Words:</label>
                    <input type="number" id="word-count-input" min="20" max="200" value="100" class="mr-2">
                    <span id="progress" class="mr-4">0/100 words</span>
                    <button id="reset-btn"
                        class="px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition">
                        Reset
                    </button>
                </div>
            </div>
        </div>

        <div id="results" class="hidden">
            <h2 class="text-2xl font-semibold mb-4">Results</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="stats-card p-4">
                    <h3 class="text-lg font-medium mb-2">Overall Statistics</h3>
                    <p>Average time per keystroke: <span id="avgTime" class="font-bold">0</span> ms</p>
                </div>

                <div class="stats-card p-4">
                    <h3 class="text-lg font-medium mb-2">Completion</h3>
                    <p>Words typed: <span id="wordsTyped" class="font-bold">0</span>/<span id="targetWords">100</span>
                    </p>
                    <p>Characters typed: <span id="charsTyped" class="font-bold">0</span></p>
                </div>
            </div>

            <div class="stats-card p-4">
                <h3 class="text-lg font-medium mb-2">Key-specific Statistics</h3>
                <div id="key-stats" class="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm"></div>
            </div>

            <button id="restart-btn"
                class="mt-6 px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">
                Restart Test
            </button>
        </div>
    </div>

    <!-- dark mode toggle button -->
    <div class="fixed bottom-4 right-4">
        <button id="dark-mode-toggle" class="px-4 py-2 bg-gray-800 text-white rounded hover:bg-gray-700 transition">
        </button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const body = document.body;
            const darkModeKey = 'dark-mode';
            const isDarkMode = localStorage.getItem(darkModeKey) === 'true';

            function updateDarkModeStyles(isDark) {
                if (isDark) {
                    body.classList.add('bg-gray-900', 'text-white');
                    document.querySelector('h1').classList.remove('text-indigo-800');
                    document.querySelector('h1').classList.add('text-indigo-300');
                    darkModeToggle.innerText = 'â˜€ï¸';
                } else {
                    body.classList.remove('bg-gray-900', 'text-white');
                    document.querySelector('h1').classList.add('text-indigo-800');
                    document.querySelector('h1').classList.remove('text-indigo-300');
                    darkModeToggle.innerText = 'ðŸŒ™';
                }

                // Update key stats colors if they exist
                if (document.getElementById('key-stats').children.length > 0) {
                    const keyStats = document.querySelectorAll('#key-stats div');
                    keyStats.forEach(stat => {
                        if (isDark) {
                            stat.classList.add('border-gray-600');
                        } else {
                            stat.classList.remove('border-gray-600');
                        }
                    });
                }
            }

            // Initial setup
            updateDarkModeStyles(isDarkMode);

            darkModeToggle.addEventListener('click', () => {
                body.classList.toggle('bg-gray-900');
                body.classList.toggle('text-white');
                const isDark = body.classList.contains('bg-gray-900');
                localStorage.setItem(darkModeKey, isDark);
                updateDarkModeStyles(isDark);
            });
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Words with a good distribution of letters
            const wordsByKeyDistribution = {
                // Words with Q, Z, X (rare letters)
                rare: ["quartz", "quiz", "quick", "squeeze", "zombie", "zigzag", "exhaust", "relax", "complex", "oxygen"],

                // Words with J, V, K (uncommon letters)
                uncommon: ["jumbo", "judge", "enjoy", "major", "vivid", "valve", "lava", "kidney", "knowledge", "market"],

                // Words with G, Y, F (moderately common)
                moderate: ["great", "galaxy", "forget", "geology", "yes", "yesterday", "yellow", "forget", "fantastic", "often"],

                // Common words for the rest
                common: [
                    "the", "be", "to", "of", "and", "a", "in", "that", "have", "it",
                    "for", "not", "on", "with", "he", "as", "you", "do", "at", "this",
                    "but", "his", "by", "from", "they", "we", "say", "her", "she", "or",
                    "an", "will", "my", "one", "all", "would", "there", "their", "what", "so",
                    "up", "out", "if", "about", "who", "get", "which", "go", "me", "when",
                    "make", "can", "like", "time", "no", "just", "him", "know", "take", "people",
                    "into", "year", "your", "good", "some", "could", "them", "see", "other", "than",
                    "then", "now", "look", "only", "come", "its", "over", "think", "also", "back",
                    "after", "use", "two", "how", "our", "work", "first", "well", "way", "even",
                    "new", "want", "because", "any", "these", "give", "day", "most", "us"
                ]
            };

            const typingArea = document.getElementById('typing-area');
            const progressDisplay = document.getElementById('progress');
            const resultsSection = document.getElementById('results');
            const avgTimeDisplay = document.getElementById('avgTime');
            const wordsTypedDisplay = document.getElementById('wordsTyped');
            const charsTypedDisplay = document.getElementById('charsTyped');
            const keyStatsDisplay = document.getElementById('key-stats');
            const restartBtn = document.getElementById('restart-btn');
            const resetBtn = document.getElementById('reset-btn');
            const wordCountInput = document.getElementById('word-count-input');
            const targetWordsDisplay = document.getElementById('targetWords');

            // Reset word count input field on page reload
            wordCountInput.value = "100";

            let targetWordCount = 100;
            let text = getBalancedRandomWords(targetWordCount);
            let currentIndex = 0;
            let keyPressTimes = new Map();
            let totalKeyPressTime = 0;
            let totalKeyPressCount = 0;
            let wordCount = 0;
            let typingStarted = false;

            // Generate words with a more balanced letter distribution
            function getBalancedRandomWords(count) {
                const words = [];

                // First ensure we have rare, uncommon, and moderate letters
                // Use about 30% of words from special categories to ensure good letter distribution
                const specialCount = Math.floor(count * 0.3);

                // Distribute special words
                const rareCount = Math.ceil(specialCount * 0.3);
                const uncommonCount = Math.ceil(specialCount * 0.3);
                const moderateCount = Math.ceil(specialCount * 0.4);

                // Add rare letter words
                for (let i = 0; i < rareCount; i++) {
                    const randomIndex = Math.floor(Math.random() * wordsByKeyDistribution.rare.length);
                    words.push(wordsByKeyDistribution.rare[randomIndex]);
                }

                // Add uncommon letter words
                for (let i = 0; i < uncommonCount; i++) {
                    const randomIndex = Math.floor(Math.random() * wordsByKeyDistribution.uncommon.length);
                    words.push(wordsByKeyDistribution.uncommon[randomIndex]);
                }

                // Add moderate letter words
                for (let i = 0; i < moderateCount; i++) {
                    const randomIndex = Math.floor(Math.random() * wordsByKeyDistribution.moderate.length);
                    words.push(wordsByKeyDistribution.moderate[randomIndex]);
                }

                // Fill the rest with common words
                const remainingCount = count - words.length;
                for (let i = 0; i < remainingCount; i++) {
                    const randomIndex = Math.floor(Math.random() * wordsByKeyDistribution.common.length);
                    words.push(wordsByKeyDistribution.common[randomIndex]);
                }

                // Shuffle the array to mix the words
                return shuffleArray(words).join(" ");
            }

            // Fisher-Yates shuffle algorithm
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Update word count from input field (with debounce)
            let debounceTimeout;
            wordCountInput.addEventListener('input', function () {
                if (this.disabled) return; // Skip if disabled

                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => {
                    let newCount = parseInt(this.value);

                    // Validate input
                    if (isNaN(newCount)) newCount = 100;
                    if (newCount < 20) newCount = 20;
                    if (newCount > 200) newCount = 200;

                    this.value = newCount;
                    targetWordCount = newCount;
                    targetWordsDisplay.textContent = newCount;
                    progressDisplay.textContent = `0/${targetWordCount} words`;

                    // Update text area immediately
                    initTypingTest();
                }, 500);
            });

            // Initialize typing area
            function initTypingTest() {
                typingArea.innerHTML = '';
                text = getBalancedRandomWords(targetWordCount);
                currentIndex = 0;
                keyPressTimes = new Map();
                totalKeyPressTime = 0;
                totalKeyPressCount = 0;
                wordCount = 0;
                typingStarted = false;

                // Enable word count input and ensure it's properly interactive
                wordCountInput.disabled = false;
                wordCountInput.style.pointerEvents = 'auto';
                wordCountInput.style.opacity = '1';

                // Focus typing area after initialization
                setTimeout(() => typingArea.focus(), 0);

                // Format text with spans for each character
                for (let i = 0; i < text.length; i++) {
                    const charSpan = document.createElement('span');
                    charSpan.innerText = text[i];
                    // Add special class for space characters to improve spacing
                    if (text[i] === ' ') {
                        charSpan.className = i === 0 ? 'char char-space char-current' : 'char char-space char-upcoming';
                    } else {
                        charSpan.className = i === 0 ? 'char char-current' : 'char char-upcoming';
                    }
                    typingArea.appendChild(charSpan);
                }

                progressDisplay.textContent = `${wordCount}/${targetWordCount} words`;
                targetWordsDisplay.textContent = targetWordCount;
                resultsSection.classList.add('hidden');
            }

            // Update display after typing
            function updateDisplay() {
                const chars = typingArea.querySelectorAll('.char');

                // Reset all characters
                chars.forEach((char, index) => {
                    const baseClass = text[index] === ' ' ? 'char char-space' : 'char';

                    if (index < currentIndex) {
                        char.className = `${baseClass} char-correct`;
                    } else if (index === currentIndex) {
                        char.className = `${baseClass} char-current`;
                    } else {
                        char.className = `${baseClass} char-upcoming`;
                    }
                });

                // Update word count
                const typedText = text.substring(0, currentIndex);
                wordCount = typedText.split(' ').filter(word => word !== '').length;
                progressDisplay.textContent = `${Math.min(wordCount, targetWordCount)}/${targetWordCount} words`;

                // Check if completed - FIXED: Only complete when all characters are typed
                if (currentIndex >= text.length) {
                    showResults();
                }
            }

            // Show results
            function showResults() {
                resultsSection.classList.remove('hidden');
                typingArea.blur();

                // Calculate and display statistics
                const avgTime = totalKeyPressTime / totalKeyPressCount;
                avgTimeDisplay.innerText = avgTime.toFixed(2);
                wordsTypedDisplay.innerText = wordCount;
                charsTypedDisplay.innerText = currentIndex;

                // Display per-key statistics (excluding spacebar)
                keyStatsDisplay.innerHTML = '';

                // Pre-calculate average times for each key for sorting
                const keyAvgTimes = new Map();
                keyPressTimes.forEach((times, keyCode) => {
                    if (keyCode !== 32) { // Skip spacebar
                        const avgKeyTime = times.reduce((a, b) => a + b, 0) / times.length;
                        keyAvgTimes.set(keyCode, avgKeyTime);
                    }
                });

                // Sort keys by average time (slowest to fastest)
                const sortedKeys = Array.from(keyAvgTimes.keys()).sort((a, b) => {
                    return keyAvgTimes.get(b) - keyAvgTimes.get(a); // Descending order
                });

                // Check if dark mode is active to apply appropriate styling
                const isDarkMode = document.body.classList.contains('bg-gray-900');
                const borderClass = isDarkMode ? 'border-gray-600' : 'border';

                // Simple gray color for all keys
                const keyColor = isDarkMode ? '#9CA3AF' : '#6B7280';

                // Performance thresholds
                const fastThreshold = avgTime * 0.8;  // 20% faster than average is good
                const slowThreshold = avgTime * 1.2;  // 20% slower than average is bad

                sortedKeys.forEach(keyCode => {
                    const times = keyPressTimes.get(keyCode);
                    const avgKeyTime = keyAvgTimes.get(keyCode);
                    const keyName = String.fromCharCode(keyCode);

                    // Determine performance color based on average time
                    let performanceColor;
                    let performanceLabel;

                    if (avgKeyTime <= fastThreshold) {
                        performanceColor = 'bg-green-100 text-green-800';
                        performanceLabel = 'Fast';
                        if (isDarkMode) {
                            performanceColor = 'bg-green-900 text-green-200';
                        }
                    } else if (avgKeyTime >= slowThreshold) {
                        performanceColor = 'bg-red-100 text-red-800';
                        performanceLabel = 'Slow';
                        if (isDarkMode) {
                            performanceColor = 'bg-red-900 text-red-200';
                        }
                    } else {
                        performanceColor = 'bg-yellow-100 text-yellow-800';
                        performanceLabel = 'Average';
                        if (isDarkMode) {
                            performanceColor = 'bg-yellow-900 text-yellow-200';
                        }
                    }

                    const keyStatDiv = document.createElement('div');
                    keyStatDiv.className = `p-2 ${borderClass} rounded`;
                    keyStatDiv.innerHTML = `
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center">
                                <div class="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold" 
                                     style="background-color: ${keyColor}">
                                    ${keyName}
                                </div>
                            </div>
                            <div class="px-2 py-1 rounded text-xs ${performanceColor}">
                                ${performanceLabel}
                            </div>
                        </div>
                        <div class="font-medium">${avgKeyTime.toFixed(2)} ms</div>
                        <div class="text-xs text-gray-500">${times.length} presses</div>
                    `;
                    keyStatsDisplay.appendChild(keyStatDiv);
                });
            }

            // Set up event listeners
            typingArea.addEventListener('click', function () {
                this.focus();
            });

            typingArea.addEventListener('keydown', function (event) {
                // Flag that typing has started
                if (!typingStarted && event.key.length === 1) {
                    typingStarted = true;
                    wordCountInput.disabled = true;
                }

                // Prevent default behavior for most keys to avoid scrolling etc.
                if (event.key !== 'F5' &&
                    !event.ctrlKey &&
                    !event.metaKey &&
                    event.key !== 'F12') {
                    event.preventDefault();
                }

                // Track keypresses (excluding spacebar for statistics)
                if ((event.key.length === 1 || event.key === ' ') && currentIndex < text.length) {
                    const startTime = performance.now();
                    const keycode = event.keyCode;

                    // Only track non-space keys for statistics
                    const shouldTrackForStats = keycode !== 32; // 32 is spacebar

                    const handleKeyUp = function (upEvent) {
                        // Only process if it's the same key that was pressed down
                        if (upEvent.keyCode === keycode) {
                            // Record timing data only for non-space keys
                            if (shouldTrackForStats) {
                                const endTime = performance.now();
                                const duration = endTime - startTime;

                                // Update statistics
                                totalKeyPressTime += duration;
                                totalKeyPressCount++;

                                if (!keyPressTimes.has(keycode)) {
                                    keyPressTimes.set(keycode, []);
                                }
                                keyPressTimes.get(keycode).push(duration);
                            }

                            // Remove this event listener
                            window.removeEventListener('keyup', handleKeyUp);
                        }
                    };

                    window.addEventListener('keyup', handleKeyUp);

                    const expectedChar = text[currentIndex];

                    // Handle typing
                    if ((event.key === ' ' && expectedChar === ' ') ||
                        (event.key === expectedChar)) {
                        currentIndex++;
                        updateDisplay();
                    }
                }
            });

            // Add event listeners to buttons
            restartBtn.addEventListener('click', function () {
                initTypingTest();
                // Explicitly ensure the word count input is enabled
                wordCountInput.disabled = false;
            });

            resetBtn.addEventListener('click', function () {
                initTypingTest();
                // Explicitly ensure the word count input is enabled
                wordCountInput.disabled = false;
            });

            // Initialize on page load
            initTypingTest();

            // Focus typing area on page load
            typingArea.focus();
        });
    </script>
</body>

</html>